# Architecture Overview

JuryRigged is a real-time multi-agent courtroom simulation.
Six AI agents are assigned courtroom roles, run through a deterministic phase sequence, and stream every turn to connected viewers via SSE.
Audience members serve as jury by voting through REST endpoints.

---

## Component Map

```
┌────────────────────────────────────────────────────────┐
│                    Express HTTP Server                 │
│  REST endpoints + SSE stream + static file serving     │
└───────────────┬────────────────────────┬───────────────┘
                │                        │
      ┌─────────▼──────────┐   ┌─────────▼──────────────┐
      │  Court Orchestrator│   │    Session Store        │
      │  (phase sequencer) │   │  in-memory or Postgres  │
      └─────────┬──────────┘   └─────────────────────────┘
                │
      ┌─────────▼──────────┐
      │    LLM Client      │
      │  OpenRouter or     │
      │  deterministic mock│
      └─────────┬──────────┘
                │
      ┌─────────▼──────────┐
      │  Content Moderation│
      │  (pattern filter)  │
      └────────────────────┘
```

---

## Agents

There are six named agents.
Each agent has a fixed personality, but their *courtroom role* is assigned at session creation.

| Agent ID  | Display Name | Natural role      |
|-----------|-------------|-------------------|
| `primus`  | Primus      | Judge (preferred) |
| `mux`     | Mux         | Bailiff (preferred) |
| `subrosa` | Subrosa     | Prosecutor (preferred) |
| `chora`   | Chora       | Defense (preferred) |
| `thaum`   | Thaum       | Witness            |
| `praxis`  | Praxis      | Witness            |

Role assignment (`src/court/roles.ts`) picks preferred agents first and fills witnesses from remaining participants.
A session requires at least **4 participants**.

---

## Court Phases

Sessions advance through phases in this strict order:

| # | Phase             | Description                                              |
|---|-------------------|----------------------------------------------------------|
| 1 | `case_prompt`     | Bailiff announces the case. Sets the scene.              |
| 2 | `openings`        | Prosecutor and defense deliver opening statements.       |
| 3 | `witness_exam`    | Judge questions witnesses; cross-examination follows.    |
| 4 | `evidence_reveal` | Optional phase (may be skipped to `closings`).           |
| 5 | `closings`        | Prosecutor and defense deliver closing arguments.        |
| 6 | `verdict_vote`    | Jury poll is open. Votes accepted for `VERDICT_VOTE_WINDOW_MS`. |
| 7 | `sentence_vote`   | Sentence poll is open. Votes accepted for `SENTENCE_VOTE_WINDOW_MS`. |
| 8 | `final_ruling`    | Judge delivers final ruling incorporating vote results.  |

Phase transitions are enforced sequentially; backward transitions are rejected.
The only allowed skip is `witness_exam → closings` (skipping `evidence_reveal`).

---

## Orchestration Flow (`src/court/orchestrator.ts`)

1. `startSession` marks the session `running`.
2. Phases advance in order; each phase calls `store.setPhase` which persists the phase and emits a `phase_changed` event.
3. Turns are generated by calling the LLM for each speaker, then moderated before being stored.
4. During vote phases, the orchestrator `sleep`s for the configured window, then closes the poll and reads results.
5. On completion, `store.completeSession` marks the session `completed`.
6. On any error, `store.failSession` marks the session `failed` with a reason string.
7. On server restart, `store.recoverInterruptedSessions` returns IDs of `running` sessions and replays orchestration from the top (turns already in the DB are preserved).

---

## Session Store (`src/store/session-store.ts`)

The store has two backends selected automatically:

| Condition              | Backend             |
|------------------------|---------------------|
| `DATABASE_URL` is set  | Postgres (durable)  |
| `DATABASE_URL` absent  | In-memory (volatile)|

The Postgres schema is under `db/migrations/001_juryrigged_core.sql`.
Migrations are run automatically on startup when the Postgres backend is active.

The store exposes an event bus (`EventEmitter`) that routes session events to SSE subscribers.

---

## Content Moderation (`src/moderation/content-filter.ts`)

Every generated turn is passed through a pattern-based content filter before storage.
Flagged content is replaced with a generic redaction placeholder:

> `[The witness statement has been redacted by the court for decorum violations.]`

A `moderation_action` event is emitted when content is redacted.
See [moderation-playbook.md](./moderation-playbook.md) for operator procedures.

---

## Vote Spam Protection (`src/moderation/vote-spam.ts`)

`VoteSpamGuard` tracks votes per `(sessionId, clientIP)` pair within a sliding time window.
Default limit: **10 votes per IP per session per 60 seconds**.
Blocked attempts emit a `vote_spam_blocked` SSE event and return HTTP 429.
The guard is pruned every 60 seconds to prevent memory growth.

---

## LLM Client (`src/llm/client.ts`)

- When `OPENROUTER_API_KEY` is set, dialogue is generated via the OpenRouter API.
- When the key is absent, a deterministic `mockReply` function returns canned responses (useful for local development).
- Raw LLM output is sanitized to strip XML artefacts, markdown formatting, and URLs before moderation.
